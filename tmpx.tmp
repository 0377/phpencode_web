<?
/**
 * dingchengliang 2014-8-11
 * each init, have each encrypt key.
 * [functions]:
 * code2file($code, $file)            //have _inc.php  
 * code2file($code, $file, false)  //no inc.php, please not make more _inc in the same folder
 * file2file($file1, $file2)             //have _inc.php  
 * file2file($file1, $file2, false)     //no inc.php,
 * folder2folder($folder1, $folder2);
 * folder2folder($folder1, $folder2, 'php|htm');  //only encode php|htm(default)
 * makeinc=true;   //not make _inc.php
 * fixedkey(true);  //fixed encryptkey
 * autoclosetags=true  //
 * 
 * selfdecode($code);   self auto decode
 * 
 * RUNMODE 
 * =PHP5.4    good, not support php6 in some case
 * =PHP6       colud not trasffer varialbles into the included files.
 * =otherxxx  good (default)
 */

if(defined('ENCODE_DEBUG')){
    echo 'bad request';
    exit;
}
// define('ENCODE_DEBUG', 1);
// define('_PHPVER' , 'PHPxxx');
mb_internal_encoding("UTF-8");

class phpEncode{
    public $funNames ;
    public $funNamesZip;
    public $funNameMuu ;

    public $symbolindex ;
    public $SYMBOL;

    public $enb64_rid = 70;
    public $encryptkey = '';
    public $copyright = "\r\n/*goodook@163.com  http://phpc.sinaapp.com*/";

    public $makeinc = true;
    public $curdomain = 'phpc.sinaapp.com';
    public $RUNMODE = 'PHPXXX';

    public $errmsg = '';
    public $autoclosetags = false;
    public $charset = 'utf-8';

    private $filter = 'php';

    private $toroot = '';
    function phpEncode($toroot = '.'){
        $this -> toroot = $toroot;
        $this -> symbolindex = 200;

        $this -> fixedkey(false);
        $this -> initfuncNames();
        $this -> RUNMODE = 'PHPXXX';
    }

    function fixedkey($isfixe = true){
        if($isfixe){
            $this -> encryptkey = '8_Q.L2';
            $this -> enb64_rid = 68;
        }else{
            $rand_arr = array(68, 70, 72, 74, 76, 78, 80, 92, 96, 98, 90);
            $this -> enb64_rid = $rand_arr[rand(0, count($rand_arr)-1)];
            $this -> encryptkey = $this -> rand_string(6);
            $this -> encryptkey = $this -> hebrev_string(6);
        }
        /**
         * echo "\r\n-----\r\n encryptkey: " .$this->encryptkey;
         * echo  "\r\n enb64_rid: " .$this->enb64_rid;
         * echo "\r\n-----\r\n";
         */
    }

    function incBody($ZipCode = ''){ 
        // $sumStart =  rand(2,40);
        $_THIS_FILE = $this -> curdomain;
        $SUMLEN = 32; //md5
        $SUMLEN = 44; //enb64(md5)
        $preg_uid = substr(md5(rand()), -6);

        $VARS = '_dingdecodefunc,getfuncName,mydecode64func,decrypt,$codepath,$Qfile_get_contents,$Qsubstr,$Qunpack,$Qgzuncompress,$Qrand,$Qchr,$Qpreg_replace,$Qassert_options,$Qassert,$Qbase64_encode,$Qconstant,$codebuf,$codebuf2,$codebuf3,$codebuf4,$codebuf5,$headerlen,$headerlen2,$headerlen3,$localfunNames,$funArray,$funname,$funcid,$Qcreate_function,$Qstr_rot13,$Qstrpos,$Qaddslashes,$Qmd5,$Qset_include_path,$Qdirname,$str_rot13,$strrev,$gzuncompress,$stripslashes,$ord,$chr,$strlen,$d_rid,$d_i,$d_tmp,$d_newtmp,$explode,$mydecode64name,$mydecode64pack,$mydecode64nameH2,$decode64nameH2,$exitfunc,$replaceCode,$untraceCode,$untraceCode2,$markchecker,$dummyNum,$_RLT';

        $vars = explode(',', $VARS);
        foreach($vars as $v){
            $v = trim($v);
            if(substr($v, 0, 1) == '$'){
                $v = substr($v, 1);
                $$v = $this -> symbol($v);
            }else{
                $$v = $this -> symbol($v, '');
            }
        }

        /**
         * \$$codebuf2=\$$Qaddslashes(\$$Qstr_rot13(@\$$Qgzuncompress($deb64(\$$Qsubstr(\$$codebuf,\$$headerlen3,-ord('".chr(4)."')))))); 
         * return $$Qpreg_replace('/$preg_uid/e',\$$Qeval.'(\"'.\$$codebuf2.'\");','$preg_uid');\\end
         * 
         * //self check
         * $incBody .= "\$$codebuf2=\$$Qfile_get_contents(__FILE__);
         * \$$Qsubstr($codebuf2,-2<<4)!=\$$Qmd5(\$$Qsubstr(\$$codebuf2,$sumStart,2<<6)) && $exitfunc();";
         */ 
        // $ZipCode = '456xxxxxxxxxxxxxxxx123';
        /**
         */
        ob_start();
        /**
         * $buf=file_get_contents('org_inc.php');
         * $buf = substr($buf,2);
         * $buf  = strtr($buf, array('<%'=>'<?=', '%>'=>'?>'));    
         * $buf = "?>$buf<?";
         * eval($buf);
         */
        include('phpEncode.class_inc.php');
        $incBody = ob_get_clean();
        $incBody = strtr($incBody , $this -> SYMBOL);
        $incBody = $this -> copyright . $incBody; 
        // $keys=(array_keys ($this->SYMBOL));
        // var_dump($keys);
        // echo join(',',$keys);
        $incBody = str_replace(array("|______"), "", $incBody);
        $incBody = str_replace(array("|___"), "", $incBody);
        if(defined('ENCODE_DEBUG')){
            $incBody = str_replace(array("//end\r\n"), "\r\n", $incBody);
        }else{
            $incBody = str_replace(array("//end\r\n"), "", $incBody);
        }
        /**
         */

        $incBody = "<?php $incBody";
        if($ZipCode){
            $incBody .= '?>' . $ZipCode;
        }
        $sum = md5($incBody);
        $sum = $this -> encrypt(chr(190) . $sum);

        $incBody = $incBody . chr(197) . $sum . ';';

        return $incBody ;
    }

    function initfuncNames(){
        $funNames = ',chr,addslashes,rand,gzuncompress,assert_options,assert,file_get_contents,substr,unpack,constant,strpos,create_function,str_rot13,md5,set_include_path,dirname,preg_replace,base64_encode,';
        $this -> funNames = $funNames;

        $funNames = str_rot13($funNames);
        $funNames = strrev ($funNames);
        $funNames = gzcompress($funNames, 9);
        $funNames = addslashes ($funNames);
        $this -> funNamesZip = $funNames;
    }
    function getfuncNameBin($func){
        $funArray = explode (',', $this -> funNames);

        $index = array_search($func, $funArray);
        if(!$index){
            echo "function '$func' not exists ";
        }

        return $index;
    }

    private function expstr($str){
        $stcount = mb_substr_count($str, '<?');
        $edcount = mb_substr_count($str, '?>');
        if($stcount > $edcount){
            $this -> errmsg .= "\r\n[warning]:maybe some php tags are not close.";
            if($this -> autoclosetags){
                return "?>" . $str . " ";
            }else
                return ;
        }

        return "?>" . $str . "<?php ";
    }

    public function file2file($from, $to, $makeINC = true){
        $codebuf = file_get_contents($from);
        if(strtolower($this -> charset) != 'utf-8'){
        }
        $buf = $this -> code2file($codebuf, $to, $makeINC);
    }

    public function folder2folder($fromDir, $toDir, $filter = 'php|html|htm'){
        $this -> from_root = $fromDir;
        $this -> to_root = $toDir;
        $this -> toroot = $toDir;
        $this -> filter = $filter;
        if($this -> makeinc){
            $incBody = $this -> incBody();
            file_put_contents($toDir . DIRECTORY_SEPARATOR . '_inc.php', $incBody);
        }
        $this -> traverse();
    }
    public function selfdecode($code0){ // 单个文件自解码
        $code = $this -> zipcode($code0);
        if(!$code){
            return $code0;
        }
        $fullcode = $this -> incBody($code);
        return $fullcode;
    }
    /**
     * code to file ,    with  _inc
     */
    public function code2file($code0, $tofile , $makeINC = true){
        $incdeep = './';
        $incdeep = '';
        $code = $this -> zipcode($code0);
        if(!$code){
            file_put_contents($tofile, $code0);
            return;
        }
        if($makeINC && $this -> makeinc){
            $incBody = $this -> incBody();
            $toDir = dirname($tofile);
            file_put_contents($toDir . DIRECTORY_SEPARATOR . '_inc.php', $incBody);
        }
        $header = "<?php " . $this -> copyright
         . " \$_f_= __FILE__;return include('" . $incdeep . "_inc.php');?>";

        $headerlen = pack('l', strlen($header));
        $BUF = $header . $code;
        $BUF .= $this -> encrypt(chr(190) . md5($BUF));
        $BUF .= $headerlen ;

        file_put_contents($tofile, $BUF);
    }
    private function zipcode($buf){
        $code = $this -> expstr($buf);
        if(!$code){
            return ;
        }
        $code = str_rot13($code);
        $code = gzcompress($code , 9);
        $code = $this -> encrypt($code);
        return $code;
    }

    function dummyCode($hasend = true){
        if(defined('ENCODE_DEBUG')){
            $code = '';
        }else{
            $code = $this -> encrypt('x' . md5(rand()));
            $len = rand(5, 15);
            for($i = 0;$i < $len;$i++){
                $code .= chr(rand(129, 255)) ;
            }
            if($hasend) $code .= ';';
        }

        return $code;
    }
    function dummySymbol($haveslash = 0){
        if(defined('ENCODE_DEBUG')){
            return '.$xxx';
        }
        /**
         * $symbol .= chr(rand(129, 214)). chr(rand(129, 255)) . chr(rand(129, 255))  
         * . chr(rand(129, 255))  . chr(rand(129, 255))   . chr(rand(129, 255)). chr(rand(129, 255))  ;
         */
        $symbol = chr(rand(129, 214));
        $len = rand(12, 24);
        for($i = 0;$i < $len;$i++){
            $symbol .= chr(rand(129, 255)) ;
        }
        if($haveslash) return ".\$" . $symbol;
        else return ".$" . $symbol;
    }

    function dummyString($str, $steps = 5){
        $new = '';
        $w = floor(strlen($str) / $steps);
        if($w < 1) $w = 1;
        for($i = 0;$i <= strlen($str);$i += $w){
            $cc = substr($str, $i, $w);
            if($i == 0) $new .= "$cc'" . $this -> dummySymbol(1);
            else $new .= ".'$cc'" . $this -> dummySymbol(1);
        }

        return $new . ".'";
    }

    function dummyNum($str, $steps = 5){
        $new = '';
        $w = floor(strlen($str) / $steps);
        if($w < 1) $w = 1;
        for($i = 0;$i < strlen($str);$i += $w){
            $cc = substr($str, $i, $w);
            if($i == 0) $new .= "'$cc'" . $this -> dummySymbol();
            else $new .= ".'$cc'" . $this -> dummySymbol(); 
            // echo "$new \r\n";
        } 
        // exit;
        return $new . $this -> dummySymbol();
    }

    function symbol($symbolname = 'errorsymbole', $SH = '$'){
        if(defined('ENCODE_DEBUG')){
            $this -> SYMBOL[$SH . $symbolname] = $SH . $symbolname;
            return $symbolname;
        }
        $this -> symbolindex += 10;
        $sindx = $this -> symbolindex ;
        $symbol = chr(rand(129, 214)) . chr(rand(0x83, 0xaa)) . chr(rand(129, 214))
         . rand($sindx, $sindx + 9) ;

        global $sindex2;
        if(!$sindex2) $sindex2 = 128;
        $sindex2++;
        $symbol = chr(rand(129, 214)) . chr(rand(129, 255)) . chr(rand(129, 255)) . chr($sindex2) . chr(rand(129, 255)) ;

        $symbol = chr(rand(129, 214));
        $len = rand(5, 10);
        for($i = 0;$i < $len;$i++){
            $symbol .= chr(rand(129, 255)) ;
        }

        $this -> SYMBOL[$SH . $symbolname] = $SH . $symbol;
        return ($symbol);
    }

    private function encrypt($cont){
        $key = $this -> encryptkey;
        $cont = $this -> enConvert($cont, $key);
        return $this -> enb64($cont);
    }
    private function enConvert($txt, $encrypt_key){
        $encrypt_key = md5($encrypt_key);
        $ctrmax = strlen($encrypt_key);
        $ctr = $ctrmax;
        $tmp = '';
        for($i = 0; $i < strlen($txt); $i++){
            $ctr = $ctr == 0 ? $ctrmax : $ctr;
            $ctr--;
            $tmp .= $txt[$i] ^ $encrypt_key[$ctr]; 
            // echo $ctr."\n";
        } 
        // /exit;
        return $tmp;
    }

    function deb64($tmp){
        $newtmp = null;
        for ($i = 0; $i < strlen($tmp); $i++) $newtmp .= ord($tmp{$i}) < 245 ? ((ord($tmp{
                  $i}) > ($this -> enb64_rid * 2) and ord($tmp{$i}) < 245) ? chr(ord($tmp{$i}) / 2) : $tmp{$i}) : '';
        return base64_decode($newtmp);
    }

    function enb64($a){
        $tmp = null;
        $b = base64_encode($a);
        for ($i = 0; $i < strlen($b); $i++){
            $tmp .= (ord($b{$i}) > $this -> enb64_rid ? chr(ord($b{$i}) * 2) : $b{$i});
        }
        return $tmp;
    }

    function enb64var($tmp){
        $tmp = base64_encode($tmp);
        for ($i = 0; $i < strlen($tmp); $i++) $newtmp .= (ord($tmp{$i}) % rand(1, 2) == 0) ? chr(rand(128, 250)) . $tmp{$i} : $tmp{$i};
        return $newtmp;
    }

    function deb10($a){
        $s = 0;
        for($i = self :: $enb64_rid1;$i < self :: $enb64_rid2;$i++){
            $ts[$i] = self :: $enb64_array[$s];
            $s++;
        }
        for($j = 0;$j < strlen($a) / 3;$j++){
            $aa = $a{$j*3} . $a{($j*3+1)} . $a{($j*3+2)};
            $as[] = $aa;
            $bs[] = $ts[$aa];
        }
        return str_replace($as, $bs, $a);
    }

    function enb10($a){
        $s = 0;
        for($i = self :: $enb64_rid1;$i < self :: $enb64_rid2;$i++){
            $ts[self :: $enb64_array[$s]] = $i;
            $s++;
        }
        for($j = 0;$j < strlen($a);$j++){
            $as[] = $a{$j};
            $bs[] = $ts[$a{$j}];
        }
        return str_replace($as, $bs, $a);
    }

    function traverse($path = ''){
        $tosubdir = $this -> to_root . DIRECTORY_SEPARATOR . $path ;

        @ copy($this -> toroot . '/_inc.php', ($tosubdir . '/_inc.php'));

        $current_dir = opendir($this -> from_root . "/" . $path);

        while(($file = readdir($current_dir)) !== false){
            $sub_dir = $this -> from_root . DIRECTORY_SEPARATOR . $path . DIRECTORY_SEPARATOR . $file;

            if($file == '.' || $file == '..'){
                continue;
            }else if(is_dir($sub_dir)){ // 如果是目录
                $tosubdir = $this -> to_root . DIRECTORY_SEPARATOR . $path . DIRECTORY_SEPARATOR . $file;

                if(!is_dir($tosubdir)) mkdir($tosubdir);

                $this -> traverse($path . DIRECTORY_SEPARATOR . $file);
            }else{ // 如果是文件
                $file2 = strtolower($file);

                if($file2 == '_inc.php') continue;

                $filters = explode('|', $this -> filter);
                $isext = false;
                foreach($filters as $ft){
                    $ft = trim($ft);
                    if(!$ft) continue;
                    $ftlen = strlen($ft);
                    if(substr($file2, - $ftlen-1) == '.' . $ft){
                        $isext = true;
                    }
                }

                $from = $this -> from_root . DIRECTORY_SEPARATOR . $path . DIRECTORY_SEPARATOR . $file;
                $to = $this -> to_root . DIRECTORY_SEPARATOR . $path . DIRECTORY_SEPARATOR . $file;
                if(!$isext){
                    copy($from, $to);
                }else{
                    $GLOBALS['curencodefile'] = $from;
                    $buf = $this -> file2file($from, $to, false);
                    echo "\r\n" . $from;
                }
            }
        }
    }

    function hebrev_string($len){
        $symbol = '';
        for($i = 0;$i < $len;$i++){
            $symbol .= chr(rand(224, 255)) ;
        }
        return $symbol;
    }
    function rand_string($len){
        $STR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#~%^&-_:;,./*()[]><{}|?abcdefghijklmnopqrstuvwxyz';
        $LEN = strlen($STR)-1;
        $tmp = '';
        for($i = 0;$i < $len;$i++){
            $j = rand(0, $LEN);
            $tmp .= $STR{$j};
        }
        return $tmp;
    }
}

?>